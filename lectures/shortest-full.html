<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shortest Path Algorithms - Complete Theory</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <header class="lecture-header">
        <h1 class="lecture-title">Module 07: Complete Theory</h1>
        <p class="lecture-subtitle">Shortest Path Algorithms</p>
    </header>

    <div class="content-wrapper">
        <a href="../index.html" class="back-link">← Return to Modules</a>

        <div class="theory-section">
            <h2>1. Introduction to Shortest Path Problems</h2>
            
            <div class="definition">
                <strong>Definition 1.1:</strong> The <em>shortest path problem</em> is to find a path between two vertices in a weighted graph such that the sum of the weights of its constituent edges is minimized.
            </div>

            <div class="concept-box">
                <h3>Types of Shortest Path Problems</h3>
                <ul>
                    <li><strong>Single-Source:</strong> From one vertex to all others (Dijkstra, Bellman-Ford)</li>
                    <li><strong>Single-Destination:</strong> From all vertices to one (reverse of single-source)</li>
                    <li><strong>Single-Pair:</strong> From one specific vertex to another</li>
                    <li><strong>All-Pairs:</strong> Between every pair of vertices (Floyd-Warshall)</li>
                </ul>
            </div>

            <div class="definition">
                <strong>Path Weight:</strong> For path P = v₁, v₂, ..., vₖ, the weight w(P) = Σ w(vᵢ, vᵢ₊₁)
                <p style="margin-top: 10px;"><strong>Shortest Path Distance:</strong> δ(u, v) = minimum w(P) over all paths from u to v</p>
            </div>
        </div>

        <div class="theory-section">
            <h2>2. Dijkstra's Algorithm</h2>
            
            <div class="definition">
                <strong>Algorithm 2.1 (Dijkstra's Algorithm):</strong> Finds shortest paths from a source vertex to all other vertices in a graph with non-negative edge weights.
            </div>

            <div class="concept-box">
                <h3>Algorithm Steps:</h3>
                <ol>
                    <li>Initialize distance to source as 0, all others as ∞</li>
                    <li>Create a set of unvisited vertices</li>
                    <li>While unvisited set is not empty:
                        <ul>
                            <li>Select vertex u with minimum distance</li>
                            <li>Mark u as visited</li>
                            <li>For each neighbor v of u: if dist[u] + w(u,v) < dist[v], update dist[v]</li>
                        </ul>
                    </li>
                </ol>
            </div>

            <div class="concept-box">
                <h3>Properties</h3>
                <ul>
                    <li><strong>Time Complexity:</strong> O(V²) with array, O((V+E) log V) with priority queue</li>
                    <li><strong>Space Complexity:</strong> O(V)</li>
                    <li><strong>Requirement:</strong> Non-negative edge weights only</li>
                    <li><strong>Greedy:</strong> Makes locally optimal choice at each step</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Example 2.1:</h4>
                <p>Apply Dijkstra's algorithm from vertex A in this graph:</p>
                <pre>
    A --2-- B
    |       |
    4       1
    |       |
    C --3-- D
                </pre>
                <p><strong>Step-by-step execution:</strong></p>
                <p>Initial: dist[A]=0, dist[B]=∞, dist[C]=∞, dist[D]=∞</p>
                <p>Step 1: Process A → dist[B]=2, dist[C]=4</p>
                <p>Step 2: Process B (min unvisited) → dist[D]=3</p>
                <p>Step 3: Process D → dist[C]=min(4,6)=4 (no change)</p>
                <p>Step 4: Process C</p>
                <p><strong>Final distances: A:0, B:2, C:4, D:3</strong></p>
            </div>

            <div class="definition">
                <strong>Theorem 2.1 (Correctness):</strong> Dijkstra's algorithm correctly computes shortest paths when all edge weights are non-negative.
                <p style="margin-top: 10px;"><em>Proof sketch:</em> By induction, each vertex added to the set has its correct shortest distance.</p>
            </div>
        </div>

        <div class="theory-section">
            <h2>3. Bellman-Ford Algorithm</h2>
            
            <div class="definition">
                <strong>Algorithm 3.1 (Bellman-Ford):</strong> Finds shortest paths from a source vertex even when edges have negative weights. Can detect negative cycles.
            </div>

            <div class="concept-box">
                <h3>Algorithm Steps:</h3>
                <ol>
                    <li>Initialize distance to source as 0, all others as ∞</li>
                    <li>Repeat V-1 times:
                        <ul>
                            <li>For each edge (u,v): if dist[u] + w(u,v) < dist[v], update dist[v]</li>
                        </ul>
                    </li>
                    <li>Check for negative cycles: if any edge can still be relaxed, negative cycle exists</li>
                </ol>
            </div>

            <div class="concept-box">
                <h3>Properties</h3>
                <ul>
                    <li><strong>Time Complexity:</strong> O(VE)</li>
                    <li><strong>Space Complexity:</strong> O(V)</li>
                    <li><strong>Advantage:</strong> Handles negative edge weights</li>
                    <li><strong>Limitation:</strong> Cannot handle negative cycles (detects them)</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Example 3.1:</h4>
                <p>Graph with negative edge:</p>
                <pre>
    A --2-- B
    |       |
    4      -3
    |       |
    C --1-- D
                </pre>
                <p><strong>Bellman-Ford from A (V-1 = 3 iterations):</strong></p>
                <p>Iteration 1: dist = {A:0, B:2, C:4, D:-1}</p>
                <p>Iteration 2: dist = {A:0, B:2, C:0, D:-1}</p>
                <p>Iteration 3: No changes (converged)</p>
                <p><strong>Note:</strong> Dijkstra would fail here due to negative edge B→D</p>
            </div>

            <div class="definition">
                <strong>Theorem 3.1:</strong> If graph contains no negative cycles reachable from source, Bellman-Ford correctly computes shortest paths after V-1 iterations.
            </div>
        </div>

        <div class="theory-section">
            <h2>4. Floyd-Warshall Algorithm</h2>
            
            <div class="definition">
                <strong>Algorithm 4.1 (Floyd-Warshall):</strong> Finds shortest paths between all pairs of vertices using dynamic programming.
            </div>

            <div class="concept-box">
                <h3>Algorithm Principle:</h3>
                <p><strong>Key Idea:</strong> Consider paths that go through vertices {1, 2, ..., k}</p>
                <p><strong>Recurrence:</strong> dist<sup>k</sup>[i][j] = min(dist<sup>k-1</sup>[i][j], dist<sup>k-1</sup>[i][k] + dist<sup>k-1</sup>[k][j])</p>
            </div>

            <div class="concept-box">
                <h3>Algorithm Steps:</h3>
                <ol>
                    <li>Initialize dist[i][j] = w(i,j) if edge exists, else ∞; dist[i][i] = 0</li>
                    <li>For k = 1 to V:
                        <ul>
                            <li>For i = 1 to V:</li>
                            <li>&nbsp;&nbsp;For j = 1 to V:</li>
                            <li>&nbsp;&nbsp;&nbsp;&nbsp;dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</li>
                        </ul>
                    </li>
                </ol>
            </div>

            <div class="concept-box">
                <h3>Properties</h3>
                <ul>
                    <li><strong>Time Complexity:</strong> O(V³)</li>
                    <li><strong>Space Complexity:</strong> O(V²)</li>
                    <li><strong>Advantage:</strong> Simple implementation, finds all pairs</li>
                    <li><strong>Works with:</strong> Negative edges (but not negative cycles)</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Example 4.1:</h4>
                <p>Graph with 3 vertices:</p>
                <pre>
    1 --4-- 2
    |       |
    3       2
    |       |
    3 --(-5)- (back to 1)
                </pre>
                <p><strong>Initial Distance Matrix:</strong></p>
                <pre>
      1  2  3
    1[0  4  3]
    2[∞  0  2]
    3[-5 ∞  0]
                </pre>
                <p><strong>After k=1 (through vertex 1):</strong></p>
                <pre>
      1  2  3
    1[0  4  3]
    2[∞  0  2]
    3[-5 -1 0]
                </pre>
                <p><strong>Final (after all iterations):</strong></p>
                <pre>
      1  2  3
    1[0  4  3]
    2[-3 0  2]
    3[-5 -1 0]
                </pre>
            </div>
        </div>

        <div class="theory-section">
            <h2>5. Comparison and Selection</h2>
            
            <div class="theory-section">
                <h3>Algorithm Comparison</h3>
                <table>
                    <tr>
                        <th>Algorithm</th>
                        <th>Time</th>
                        <th>Negative Edges?</th>
                        <th>Use When</th>
                    </tr>
                    <tr>
                        <td>Dijkstra</td>
                        <td>O((V+E) log V)</td>
                        <td>No</td>
                        <td>Non-negative, single source</td>
                    </tr>
                    <tr>
                        <td>Bellman-Ford</td>
                        <td>O(VE)</td>
                        <td>Yes</td>
                        <td>Negative edges, detect cycles</td>
                    </tr>
                    <tr>
                        <td>Floyd-Warshall</td>
                        <td>O(V³)</td>
                        <td>Yes</td>
                        <td>All pairs, dense graphs</td>
                    </tr>
                    <tr>
                        <td>BFS (unweighted)</td>
                        <td>O(V+E)</td>
                        <td>N/A</td>
                        <td>Unweighted graphs only</td>
                    </tr>
                </table>
            </div>

            <div class="concept-box">
                <h3>Selection Guidelines:</h3>
                <ul>
                    <li><strong>Use Dijkstra:</strong> Non-negative weights, need efficiency, single source</li>
                    <li><strong>Use Bellman-Ford:</strong> Negative edges present, need to detect negative cycles</li>
                    <li><strong>Use Floyd-Warshall:</strong> Need all-pairs distances, small to medium graphs</li>
                    <li><strong>Use BFS:</strong> Unweighted graph (all edges weight 1)</li>
                </ul>
            </div>
        </div>

        <div class="theory-section">
            <h2>6. Advanced Topics</h2>
            
            <div class="concept-box">
                <h3>A* Search Algorithm</h3>
                <p><strong>Enhancement of Dijkstra:</strong> Uses heuristic function h(v) to guide search</p>
                <p><strong>Priority:</strong> f(v) = g(v) + h(v), where g(v) is distance from start</p>
                <p><strong>Admissible Heuristic:</strong> h(v) never overestimates actual distance</p>
                <p><strong>Use:</strong> When you know target and have good heuristic (e.g., Euclidean distance)</p>
            </div>

            <div class="concept-box">
                <h3>Johnson's Algorithm</h3>
                <p><strong>Purpose:</strong> All-pairs shortest paths more efficiently than Floyd-Warshall</p>
                <p><strong>Method:</strong> Reweight edges, then run Dijkstra from each vertex</p>
                <p><strong>Time:</strong> O(V²log V + VE)</p>
                <p><strong>Better than Floyd-Warshall when:</strong> Graph is sparse</p>
            </div>
        </div>

        <div class="theory-section">
            <h2>Practice Problems</h2>

            <div class="question-card">
                <h4>Problem 1:</h4>
                <p>Why does Dijkstra's algorithm fail with negative edge weights?</p>
                <details>
                    <summary>Solution</summary>
                    <p>Dijkstra assumes once a vertex is processed (marked as visited), its shortest distance is final.</p>
                    <p>With negative edges, a later path through a negative edge could provide a shorter distance.</p>
                    <p><strong>Example:</strong> A→B (weight 5), A→C (weight 2), C→B (weight -4)</p>
                    <p>Dijkstra would finalize B with distance 5, missing the better path A→C→B = -2</p>
                </details>
            </div>

            <div class="question-card">
                <h4>Problem 2:</h4>
                <p>A graph has 100 vertices and 200 edges (sparse). Which algorithm is best for all-pairs shortest paths?</p>
                <details>
                    <summary>Solution</summary>
                    <p>Compare options:</p>
                    <p>• Floyd-Warshall: O(V³) = O(100³) = 1,000,000 operations</p>
                    <p>• Johnson's (or V×Dijkstra): O(V²log V + VE) ≈ O(100²×log(100) + 100×200) ≈ 86,600 operations</p>
                    <p><strong>Answer: Johnson's algorithm (or run Dijkstra V times) is more efficient</strong></p>
                </details>
            </div>

            <div class="question-card">
                <h4>Problem 3:</h4>
                <p>How can Bellman-Ford detect a negative cycle?</p>
                <details>
                    <summary>Solution</summary>
                    <p>After V-1 iterations, if no negative cycles, all distances are optimal.</p>
                    <p>Run one more iteration (V-th): if any distance can still be reduced, negative cycle exists.</p>
                    <p><strong>Reason:</strong> Shortest simple paths have at most V-1 edges. Further reduction implies a cycle.</p>
                </details>
            </div>

            <div class="question-card">
                <h4>Problem 4:</h4>
                <p>In Floyd-Warshall, why do we need three nested loops?</p>
                <details>
                    <summary>Solution</summary>
                    <p>The three loops represent:</p>
                    <p>• Outer loop (k): intermediate vertices to consider</p>
                    <p>• Middle loop (i): all source vertices</p>
                    <p>• Inner loop (j): all destination vertices</p>
                    <p>For each pair (i,j), we check if going through k gives a shorter path.</p>
                    <p><strong>Dynamic Programming:</strong> Builds solution using subproblems (paths through vertices 1..k-1)</p>
                </details>
            </div>

            <div class="question-card">
                <h4>Problem 5:</h4>
                <p>Can we use Dijkstra for finding longest paths by negating weights?</p>
                <details>
                    <summary>Solution</summary>
                    <p><strong>No!</strong> Negating weights creates negative edges.</p>
                    <p>Dijkstra requires non-negative weights.</p>
                    <p><strong>Alternative:</strong> Use modified Bellman-Ford (maximize instead of minimize)</p>
                    <p>Or for DAGs, use topological sort with longest path calculation.</p>
                </details>
            </div>

            <div class="question-card">
                <h4>Problem 6:</h4>
                <p>What's the space complexity trade-off between algorithms?</p>
                <details>
                    <summary>Solution</summary>
                    <p>• Dijkstra: O(V) - stores distances and priority queue</p>
                    <p>• Bellman-Ford: O(V) - stores distances only</p>
                    <p>• Floyd-Warshall: O(V²) - stores V×V distance matrix</p>
                    <p><strong>Trade-off:</strong> Floyd-Warshall uses more space but provides all-pairs information</p>
                    <p>For single-source, Dijkstra/Bellman-Ford are more space-efficient</p>
                </details>
            </div>
        </div>

        <div class="summary-panel">
            <h3>Chapter Summary</h3>
            <ol>
                <li>Shortest path problems are fundamental in graph theory and applications</li>
                <li>Dijkstra: efficient for non-negative weights, greedy approach</li>
                <li>Bellman-Ford: handles negative weights, can detect negative cycles</li>
                <li>Floyd-Warshall: finds all-pairs distances using dynamic programming</li>
                <li>Algorithm choice depends on graph properties and requirements</li>
                <li>Real applications: GPS, networking, game AI, resource optimization</li>
            </ol>
        </div>

        <div style="text-align: center; margin: 30px 0;">
            <a href="shortest-summary.html" class="btn btn-secondary">View Quick Summary</a>
        </div>

        <a href="../index.html" class="back-link">← Return to Modules</a>
    </div>

    <script src="../script.js"></script>
</body>
</html>
