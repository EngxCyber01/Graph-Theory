<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Representations - Complete Theory</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <header class="lecture-header">
        <h1 class="lecture-title">Module 02: Complete Theory</h1>
        <p class="lecture-subtitle">Graph Representation Methods</p>
    </header>

    <div class="content-wrapper">
        <a href="../index.html" class="back-link">← Return to Modules</a>

        <div class="theory-section">
            <h2>1. Introduction to Graph Representations</h2>
            <p>A graph representation is a data structure used to store graph information. The choice of representation affects:</p>
            <ul>
                <li>Space complexity</li>
                <li>Time complexity of operations</li>
                <li>Ease of implementation</li>
                <li>Suitability for specific algorithms</li>
            </ul>

            <div class="concept-box">
                <h3>Key Trade-offs</h3>
                <ul>
                    <li><strong>Space vs Time:</strong> More space can enable faster operations</li>
                    <li><strong>Dense vs Sparse:</strong> Graph density determines optimal choice</li>
                    <li><strong>Static vs Dynamic:</strong> Frequency of graph modifications</li>
                </ul>
            </div>
        </div>

        <div class="theory-section">
            <h2>2. Adjacency Matrix</h2>
            
            <div class="definition">
                <strong>Definition 2.1:</strong> For a graph G = (V, E) with n vertices, the <em>adjacency matrix</em> A is an n × n matrix where:
                <br>
                A[i][j] = 1 if (i, j) ∈ E
                <br>
                A[i][j] = 0 otherwise
            </div>

            <div class="example-box">
                <h4>Example 2.1:</h4>
                <p>Graph with V = {1, 2, 3, 4}, E = {(1,2), (1,3), (2,3), (3,4)}</p>
                <pre>
     1  2  3  4
1 [  0  1  1  0  ]
2 [  1  0  1  0  ]
3 [  1  1  0  1  ]
4 [  0  0  1  0  ]
                </pre>
            </div>

            <div class="concept-box">
                <h3>Properties of Adjacency Matrix</h3>
                <ul>
                    <li><strong>Undirected graphs:</strong> Matrix is symmetric (A[i][j] = A[j][i])</li>
                    <li><strong>Diagonal elements:</strong> A[i][i] = 1 indicates self-loop</li>
                    <li><strong>Row/column sum:</strong> Equals degree of that vertex</li>
                    <li><strong>Total 1s:</strong> 2m for undirected, m for directed</li>
                </ul>
            </div>

            <div class="theorem-box">
                <strong>Theorem 2.1:</strong> For adjacency matrix A, the entry (A<sup>k</sup>)[i][j] equals the number of paths of length k from vertex i to vertex j.
                <br><br>
                <strong>Proof sketch:</strong> By induction on k. Base case k=1 is definition. For k→k+1, paths of length k+1 from i to j must go through some intermediate vertex, giving the matrix multiplication formula.
            </div>

            <div class="concept-box">
                <h3>Complexity Analysis</h3>
                <ul>
                    <li><strong>Space:</strong> O(n²) regardless of edge count</li>
                    <li><strong>Check if edge exists:</strong> O(1)</li>
                    <li><strong>Find all neighbors:</strong> O(n)</li>
                    <li><strong>Add/remove edge:</strong> O(1)</li>
                    <li><strong>Add vertex:</strong> O(n²) - need to resize</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Example 2.2: Weighted Graphs</h4>
                <p>For weighted graphs, store weight instead of 1:</p>
                <pre>
     A   B   C   D
A [  0   3   ∞   7  ]
B [  3   0   2   ∞  ]
C [  ∞   2   0   1  ]
D [  7   ∞   1   0  ]
                </pre>
                <p>Use ∞ or special value for non-edges</p>
            </div>
        </div>

        <div class="theory-section">
            <h2>3. Adjacency List</h2>
            
            <div class="definition">
                <strong>Definition 3.1:</strong> An <em>adjacency list</em> representation stores for each vertex v ∈ V a list of all vertices adjacent to v.
            </div>

            <div class="example-box">
                <h4>Example 3.1:</h4>
                <p>Same graph: V = {1, 2, 3, 4}, E = {(1,2), (1,3), (2,3), (3,4)}</p>
                <pre>
1 → [2, 3]
2 → [1, 3]
3 → [1, 2, 4]
4 → [3]
                </pre>
            </div>

            <div class="concept-box">
                <h3>Complexity Analysis</h3>
                <ul>
                    <li><strong>Space:</strong> O(n + m) - optimal for sparse graphs</li>
                    <li><strong>Check if edge exists:</strong> O(deg(v)) average</li>
                    <li><strong>Find all neighbors:</strong> O(deg(v)) - optimal</li>
                    <li><strong>Add edge:</strong> O(1) with dynamic arrays</li>
                    <li><strong>Add vertex:</strong> O(1) - just add new list</li>
                </ul>
            </div>

            <div class="theorem-box">
                <strong>Theorem 3.1:</strong> For an undirected graph with m edges represented as an adjacency list, the sum of all list lengths equals 2m.
                <br><br>
                <strong>Proof:</strong> Each edge (u,v) appears twice: once in u's list and once in v's list. Therefore, total list entries = 2m. ∎
            </div>

            <div class="concept-box">
                <h3>Advantages of Adjacency Lists</h3>
                <ul>
                    <li><strong>Space-efficient:</strong> Only stores actual edges</li>
                    <li><strong>Fast iteration:</strong> Over neighbors without examining all vertices</li>
                    <li><strong>Dynamic:</strong> Easy to add vertices and edges</li>
                    <li><strong>Realistic:</strong> Most real-world graphs are sparse (m ≪ n²)</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Example 3.2: Real-World Sparsity</h4>
                <p>Facebook social graph (as of ~2020):</p>
                <ul>
                    <li>n ≈ 2.8 billion users</li>
                    <li>Average degree ≈ 200 friends</li>
                    <li>m ≈ 280 billion edges</li>
                    <li>n² ≈ 7.8 × 10<sup>18</sup> possible edges</li>
                    <li>m/n² ≈ 0.000036 (extremely sparse!)</li>
                </ul>
                <p>Matrix: 7.8 × 10<sup>18</sup> bytes = 7.8 exabytes</p>
                <p>List: 280 billion edges × 8 bytes ≈ 2.2 terabytes</p>
                <p><strong>Savings: 99.9997%</strong></p>
            </div>
        </div>

        <div class="theory-section">
            <h2>4. Edge List</h2>
            
            <div class="definition">
                <strong>Definition 4.1:</strong> An <em>edge list</em> is simply a list of all edges, where each edge is stored as a pair (or triple for weighted graphs).
            </div>

            <div class="example-box">
                <h4>Example 4.1:</h4>
                <p>Graph edges stored as list:</p>
                <pre>
[(1, 2), (1, 3), (2, 3), (3, 4)]
                </pre>
                <p>For weighted graph:</p>
                <pre>
[(1, 2, 3), (1, 3, 5), (2, 3, 2), (3, 4, 1)]
                </pre>
            </div>

            <div class="concept-box">
                <h3>Complexity Analysis</h3>
                <ul>
                    <li><strong>Space:</strong> O(m) - most space-efficient</li>
                    <li><strong>Check if edge exists:</strong> O(m) - must scan all</li>
                    <li><strong>Find all neighbors:</strong> O(m) - must scan all</li>
                    <li><strong>Add edge:</strong> O(1) - append to list</li>
                    <li><strong>Iterate all edges:</strong> O(m) - optimal</li>
                </ul>
            </div>

            <div class="concept-box">
                <h3>When to Use Edge Lists</h3>
                <ul>
                    <li>Algorithms that primarily iterate over edges (e.g., Kruskal's MST)</li>
                    <li>When graph is read-once and not queried</li>
                    <li>As intermediate format for processing</li>
                    <li>For minimal memory footprint</li>
                </ul>
            </div>
        </div>

        <div class="theory-section">
            <h2>5. Comparison and Selection Guide</h2>
            
            <div class="concept-box">
                <h3>Dense vs Sparse Graphs</h3>
                <div class="definition">
                    <strong>Definition:</strong> A graph is <em>dense</em> if m = Θ(n²), and <em>sparse</em> if m = O(n).
                </div>
                <ul>
                    <li><strong>Dense example:</strong> Complete graph K<sub>n</sub> has m = n(n-1)/2 ≈ n²/2</li>
                    <li><strong>Sparse example:</strong> Tree has m = n - 1</li>
                    <li><strong>Real-world:</strong> Most networks are sparse (social, web, road)</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Example 5.1: Representation Choice</h4>
                <p><strong>Scenario 1:</strong> Social network with 1 million users, average 100 friends</p>
                <ul>
                    <li>n = 10<sup>6</sup>, m ≈ 5 × 10<sup>7</sup></li>
                    <li>Matrix: 10<sup>12</sup> entries = 1 TB (mostly zeros)</li>
                    <li>List: 10<sup>8</sup> entries = 800 MB</li>
                    <li><strong>Choice: Adjacency List</strong> (1000× space savings)</li>
                </ul>

                <p><strong>Scenario 2:</strong> Flight routes between 50 major cities (heavily connected)</p>
                <ul>
                    <li>n = 50, m ≈ 500 (dense)</li>
                    <li>Matrix: 2,500 entries = 2.5 KB</li>
                    <li>List: 1,000 entries = 8 KB</li>
                    <li><strong>Choice: Either works</strong> (but matrix gives O(1) lookups)</li>
                </ul>
            </div>

            <div class="theorem-box">
                <strong>Selection Heuristic:</strong>
                <ul>
                    <li>If m > n²/4: Use adjacency matrix</li>
                    <li>If m < n²/4: Use adjacency list</li>
                    <li>If only edge iteration needed: Use edge list</li>
                </ul>
            </div>
        </div>

        <div class="theory-section">
            <h2>6. Advanced Representations</h2>

            <div class="concept-box">
                <h3>Incidence Matrix</h3>
                <p>n × m matrix where rows = vertices, columns = edges</p>
                <ul>
                    <li>Entry is 1 if vertex is incident to edge</li>
                    <li>Useful for circuit theory, flow problems</li>
                    <li>Space: O(nm) - rarely used</li>
                </ul>
            </div>

            <div class="concept-box">
                <h3>Hybrid Representations</h3>
                <ul>
                    <li><strong>Hash table + lists:</strong> O(1) edge checks, O(n+m) space</li>
                    <li><strong>Matrix + lists:</strong> Best of both worlds for moderate size</li>
                    <li><strong>Compressed sparse row:</strong> Optimized for sparse matrices</li>
                </ul>
            </div>
        </div>

        <div class="practice-section">
            <h2>Practice Problems</h2>
            
            <div class="question-card">
                <h4>Problem 1:</h4>
                <p>For a graph with n=1000 vertices and m=5000 edges, calculate space used by matrix vs list.</p>
                <details>
                    <summary>Solution</summary>
                    <p><strong>Adjacency Matrix:</strong></p>
                    <ul>
                        <li>Size: n × n = 1000 × 1000 = 1,000,000 entries</li>
                        <li>Using 1 byte per entry: 1 MB</li>
                    </ul>
                    <p><strong>Adjacency List:</strong></p>
                    <ul>
                        <li>Entries: 2m = 10,000 (undirected)</li>
                        <li>Using 4 bytes per entry: 40 KB</li>
                        <li>Plus array overhead: ~50 KB total</li>
                    </ul>
                    <p><strong>Savings: 95%</strong> with adjacency list</p>
                </details>
            </div>

            <div class="question-card">
                <h4>Problem 2:</h4>
                <p>Given adjacency matrix A, how many edges in the graph if sum of all entries is 24?</p>
                <details>
                    <summary>Solution</summary>
                    <p>For undirected graph: each edge counted twice in matrix</p>
                    <p>Total 1s = 2m</p>
                    <p>2m = 24</p>
                    <p><strong>Answer: m = 12 edges</strong></p>
                </details>
            </div>

            <div class="question-card">
                <h4>Problem 3:</h4>
                <p>Prove that in an adjacency list for an undirected graph, the sum of list lengths equals twice the number of edges.</p>
                <details>
                    <summary>Solution</summary>
                    <p><strong>Proof:</strong></p>
                    <p>Let L = sum of all list lengths</p>
                    <p>Each edge (u,v) contributes exactly 2 to L:</p>
                    <ul>
                        <li>v appears in u's list (+1)</li>
                        <li>u appears in v's list (+1)</li>
                    </ul>
                    <p>Therefore: L = 2m ∎</p>
                </details>
            </div>

            <div class="question-card">
                <h4>Problem 4:</h4>
                <p>What does A³[i][j] represent in adjacency matrix A?</p>
                <details>
                    <summary>Solution</summary>
                    <p>By Theorem 2.1: A<sup>k</sup>[i][j] counts paths of length k</p>
                    <p>Therefore A³[i][j] = number of paths of length 3 from i to j</p>
                    <p><strong>Example:</strong> In triangle (3-cycle), A³[i][i] = 2 (two ways around)</p>
                </details>
            </div>

            <div class="question-card">
                <h4>Problem 5:</h4>
                <p>Design a representation for a graph that supports O(1) edge existence checks and O(deg(v)) neighbor iteration.</p>
                <details>
                    <summary>Solution</summary>
                    <p><strong>Hybrid approach:</strong></p>
                    <ul>
                        <li>Adjacency list for neighbor iteration</li>
                        <li>Hash set per vertex for O(1) membership check</li>
                    </ul>
                    <p><strong>Space:</strong> O(n + m) still</p>
                    <p><strong>Operations:</strong></p>
                    <ul>
                        <li>Check edge: O(1) via hash set</li>
                        <li>Iterate neighbors: O(deg(v)) via list</li>
                        <li>Best of both worlds!</li>
                    </ul>
                </details>
            </div>

            <div class="question-card">
                <h4>Problem 6:</h4>
                <p>Facebook has 2.8B users with average 200 friends. Would you use matrix or list? Calculate space difference.</p>
                <details>
                    <summary>Solution</summary>
                    <p>n = 2.8 × 10<sup>9</sup>, avg degree = 200</p>
                    <p>m ≈ (n × 200)/2 = 2.8 × 10<sup>11</sup> edges</p>
                    <p><strong>Matrix:</strong></p>
                    <ul>
                        <li>n² = 7.84 × 10<sup>18</sup> entries</li>
                        <li>At 1 byte each: 7.8 exabytes</li>
                    </ul>
                    <p><strong>List:</strong></p>
                    <ul>
                        <li>2m entries = 5.6 × 10<sup>11</sup></li>
                        <li>At 8 bytes each: 4.5 terabytes</li>
                    </ul>
                    <p><strong>Decision: Adjacency List</strong></p>
                    <p>Savings: 7.8 EB vs 4.5 TB ≈ 1.7 million times smaller!</p>
                </details>
            </div>
        </div>

        <div class="summary-panel">
            <h3>Chapter Summary</h3>
            <ol>
                <li>Three main representations: matrix, list, edge list</li>
                <li>Matrix: O(n²) space, O(1) edge checks - best for dense graphs</li>
                <li>List: O(n+m) space, O(deg(v)) operations - best for sparse graphs</li>
                <li>Real-world graphs are typically sparse → use adjacency lists</li>
                <li>Choice depends on graph density and required operations</li>
                <li>Matrix powers count paths (A<sup>k</sup>[i][j] = paths of length k)</li>
            </ol>
        </div>

        <div style="text-align: center; margin: 30px 0;">
            <a href="representation-summary.html" class="btn btn-secondary">View Quick Summary</a>
        </div>

        <a href="../index.html" class="back-link">← Return to Modules</a>
    </div>

    <script src="../script.js"></script>
</body>
</html>